<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Activation.BuiltinHandlerActivator">
            <summary>
            Built-in handler activator that can be used when dependency injection is not required, or when inline
            lambda-based handler are wanted
            </summary>
        </member>
        <member name="T:Rebus.Activation.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.Activation.IHandlerActivator"/> with the expectation that it is backed by some kind of IoC container that can hold
            a bus instance (which it naturally should be able to inject into handlers when they're activated)
            </summary>
        </member>
        <member name="T:Rebus.Activation.IHandlerActivator">
            <summary>
            Responsible for creating handlers for a given message type
            </summary>
        </member>
        <member name="M:Rebus.Activation.IHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Must return all relevant handler instances for the given message
            </summary>
        </member>
        <member name="M:Rebus.Activation.IContainerAdapter.SetBus(Rebus.Bus.IBus)">
            <summary>
            Sets the bus instance that this <see cref="T:Rebus.Activation.IContainerAdapter"/> should be able to inject when resolving handler instances
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Returns all relevant handler instances for the given message by looking up compatible registered functions and instance factory methods.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.SetBus(Rebus.Bus.IBus)">
            <summary>
            Stores the bus instance
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> and the current <see cref="T:Rebus.Pipeline.IMessageContext"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Dispose">
            <summary>
            Disposes the contained bus instance
            </summary>
        </member>
        <member name="P:Rebus.Activation.BuiltinHandlerActivator.Bus">
            <summary>
            Gets the bus instance that this activator was configured with
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages`1">
            <summary>
            Message handler interface. Implement this in order to get to handle messages of a specific type
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages">
            <summary>
            Base message handler interface. Don't implement this one directly, it would give you nothing
            </summary>
        </member>
        <member name="M:Rebus.Handlers.IHandleMessages`1.Handle(`0)">
            <summary>
            This method will be invoked with a message of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.AuditHeaders">
            <summary>
            Headers relevant when using message auditing
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.AuditTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message copy was forwarded to the audit queue.
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the audited message was received.
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleQueue">
            <summary>
            Header with the queue name from which the message was received. 
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.MachineName">
            <summary>
            Name of the machine that processed/published the message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions.EnableMessageAuditing(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.IncomingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IIncomingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each incoming message to be handled.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IStep">
            <summary>
            General step interface - allows for treating incoming/outgoing pipeline steps equally in some regards, even though they're different
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the incoming message :)
            </summary>
        </member>
        <member name="T:Rebus.Bus.IInitializable">
            <summary>
            Anything that is resolved with the injectionist can be marked as initializable by implementing this interface, which
            will then have its <see cref="M:Rebus.Bus.IInitializable.Initialize"/> method called before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.Bus.IInitializable.Initialize">
            <summary>
            Initializes the instance
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.IncomingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.OutgoingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IOutgoingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each outgoing message to be sent.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.OutgoingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage">
            <summary>
            Saga snapshot storage that archives a snapshot of the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.ISagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Archives the given saga data under its current ID and revision
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.EnableSagaAuditing(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.OutputToLog(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage})">
            <summary>
            Configures Rebus to output saga snapshots to the log. Each saga data mutation will be logged as a serialized JSON object without type information
            with INFO level to the class-logger of <see cref="T:Rebus.Auditing.Sagas.LoggerSagaSnapperShotter"/>.
            This is probably mostly useful in debugging scenarios, or as a simple auditing mechanism in cases where sagas don't expect a lot of traffic.
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys">
            <summary>
            Contains keys of metadata elements that can be found alongside saga data snapshots when saga auditing has been enabled
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.HandleQueue">
            <summary>
            Key of the input queue address of the endpoint that handled the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaDataType">
            <summary>
            Key of the type of the saga data
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaHandlerType">
            <summary>
            Key of the type of the saga handler that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageType">
            <summary>
            Key of the type of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageId">
            <summary>
            Key of the ID of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MachineName">
            <summary>
            Key of the machine name on which the saga data was brought to the current state
            </summary>
        </member>
        <member name="T:Rebus.Backoff.BackoffConfigurationExtensions">
            <summary>
            Configuration extensions for customizing the backoff behavior
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.TimeSpan[])">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="T:Rebus.Backoff.SimpleCustomizedBackoffStrategy">
            <summary>
            Simple implementation of <see cref="T:Rebus.Workers.IBackoffStrategy"/> that is capable of having the backoff times customized
            </summary>
        </member>
        <member name="T:Rebus.Workers.IBackoffStrategy">
            <summary>
            Implements a strategy with which workers will back off in idle periods. Please note that the <see cref="T:Rebus.Workers.IBackoffStrategy"/>
            implementations must be reentrant!
            </summary>
        </member>
        <member name="M:Rebus.Workers.IBackoffStrategy.Wait">
            <summary>
            Asynchronously executes the next wait operation, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
        </member>
        <member name="M:Rebus.Workers.IBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.#ctor(System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Constructs the backoff strategy with the given waiting times
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.Wait">
            <summary>
            Asynchronously executes the next wait operation, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            This is the main bus thing which you'll most likely hold on to
            </summary>
        </member>
        <member name="T:Rebus.Bus.IBus">
            <summary>
            This is the main bus API
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the delivery of the message by attaching a <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to it and delivering it to the configured timeout manager endpoint
            (defaults to be ourselves). When the time is right, the deferred message is returned to the address indicated by the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.IBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.Workers.IWorkerFactory,Rebus.Routing.IRouter,Rebus.Transport.ITransport,Rebus.Pipeline.IPipeline,Rebus.Pipeline.IPipelineInvoker,Rebus.Subscriptions.ISubscriptionStorage,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the bus.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the bus by adding the specified number of workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> is specified
            in a header, the instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if
            called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerPublish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified event message on the specified topic, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerSubscribe(System.String)">
            <summary>
            Subscribes to the specified topic. If the current subscription storage is centralized, the subscription will be established right away. Otherwise, a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerUnsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified topic. If the current subscription storage is centralized, the subscription will be removed right away. Otherwise, an <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, allowing them to finish handling the current message (for up to 1 minute) before exiting
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers by adding/removing one worker at a time until
            the desired number is reached
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Gets a label for this bus instance - e.g. "RebusBus 2" if this is the 2nd instance created, ever, in the current process
            </summary>
        </member>
        <member name="E:Rebus.Bus.RebusBus.Disposed">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IAdvancedApi">
            <summary>
            API for the advanced features of the bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Workers">
            <summary>
            Gets an API to query/control various aspects around Rebus' workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Topics">
            <summary>
            Gets an API to do pub/sub on raw string-based topics
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Routing">
            <summary>
            Gets an API to explicitly route messages
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.TransportMessage">
            <summary>
            Gets an API to perform operations with the transport message currently being handled
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITransportMessageApi">
            <summary>
            Contains operations that can be performed on the transport message currently being handled
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Forward(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Forwards the transport message currently being handled to the specified queue, optionally supplying some extra headers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the transport message currently being handled some time into the future, optionally specifying some additional headers
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IRoutingApi">
            <summary>
            Provides a raw API for explicitly routing messages to other endpoints
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Send(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IWorkersApi">
            <summary>
            Defines an API for working with workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IWorkersApi.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers, blocking until the desired number has been reached
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IWorkersApi.Count">
            <summary>
            Gets how many workers are currently running
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITopicsApi">
            <summary>
            Provides the raw topic-based pub/sub API which is used underneath the type-based pub/sub api provided by <see cref="T:Rebus.Bus.IBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Publish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified message to the specified topic. Default behavior is to look up the addresses of those who subscribed to the given topic
            by calling <see cref="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)"/> but the transport may override this behavior if it has special capabilities.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Subscribe(System.String)">
            <summary>
            Subscribes the current endpoint to the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is registered immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and a
            <see cref="T:Rebus.Messages.Control.SubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the current endpoint from the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is removed immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and an
            <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="T:Rebus.Config.OneWayClientBackdoor">
            <summary>
            Helper that gives a backdoor to the configuration <see cref="T:Rebus.Config.Options"/>, allowing for one-way client settings
            to be set.
            </summary>
        </member>
        <member name="M:Rebus.Config.OneWayClientBackdoor.ConfigureOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Uses the given <see cref="T:Rebus.Config.StandardConfigurer`1"/> of <see cref="T:Rebus.Transport.ITransport"/> to set the number of workers
            to zero (effectively disabling message processing) and installs a decorator of <see cref="T:Rebus.Bus.IBus"/> that prevents
            further modification of the number of workers (thus preventing accidentally starting workers when there's no input queue).
            </summary>
        </member>
        <member name="T:Rebus.Encryption.DecryptMessagesIncomingStep">
            <summary>
            Incoming message step that checks for the prensence of the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header, decrypting
            the message body if it is present.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.#ctor(Rebus.Encryption.Encryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Descrypts the incoming <see cref="T:Rebus.Messages.TransportMessage"/> if it has the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionConfigurationExtensions">
            <summary>
            Configuration extensions for enabling encrypted message bodies
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableEncryption(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages. Please note that it's only the message bodies that are
            encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionHeaders">
            <summary>
            Special headers that are used when the message contents are encrypted
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption">
            <summary>
            Optional header element that specifies an encryption algorithm that the contents have been encrypted with
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentInitializationVector">
            <summary>
            When the contents have been encrypted, this header has the IV
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptMessagesOutgoingStep">
            <summary>
            Outgoing pipeline step that encrypts the contents of the outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.#ctor(Rebus.Encryption.Encryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Encrypts the outgoing <see cref="T:Rebus.Messages.TransportMessage"/> and adds appropriate headers
            </summary>
        </member>
        <member name="T:Rebus.Encryption.Encryptor">
            <summary>
            Helps with encrypting/decripting byte arrays, using the <see cref="T:System.Security.Cryptography.RijndaelManaged"/> algorithm
            </summary>
        </member>
        <member name="M:Rebus.Encryption.Encryptor.#ctor(System.String)">
            <summary>
            Creates the encrptor with the specified key - the key must be a valid, base64-encoded key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Rebus.Encryption.Encryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given array of bytes, using the configured key. Returns an <see cref="T:Rebus.Encryption.EncryptedData"/> containing the encrypted
            bytes and the generated salt.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.Encryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the given <see cref="T:Rebus.Encryption.EncryptedData"/> using the configured key.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptedData">
            <summary>
            Represents a chunk of encrypted data along with the salt (a.k.a. "Initialization Vector"/"IV") that was used to encrypt it.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptedData.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructs an instance from the given bytes and iv.
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Bytes">
            <summary>
            Gets the raw data from this encrypted data instance
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Iv">
            <summary>
            Gets the salt (a.k.a. "Initialization Vector"/"IV") from this encrypted data instance
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusApplicationException">
            <summary>
            Generic application exception to use when something bad happens that is pretty unexpected and should be taken seriously
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DateTimeExtensions">
            <summary>
            Defines a few nice extensions for making working with <see cref="T:System.DateTimeOffset"/> more nice
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ElapsedUntilNow(System.DateTimeOffset)">
            <summary>
            Gets the time from this instant until now (as returned by <see cref="P:Rebus.Time.RebusTime.Now"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToIso8601DateTimeOffset(System.DateTimeOffset)">
            <summary>
            Serializes this instant with the "O" format, i.e. ISO8601-compliant
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToDateTimeOffset(System.String)">
            <summary>
            Parses an ISO8601-compliant string into a proper <see cref="T:System.DateTimeOffset"/>
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> that allows for specifying additional handler types
            whose order to fix
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1">
            <summary>
            Specifies the handler that will be put next in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            again to specify the next handler
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.ReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)"/> that can be used as a
            fluent syntax to specify the desired order of the handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1">
            <summary>
            Specifies the handler that will be put first in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            any number of times to specify the next handler
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.GetIndex(System.Object)">
            <summary>
            Gets the sorting index for the given handler
            </summary>
        </member>
        <member name="T:Rebus.Messages.HeaderAttribute">
            <summary>
            Header attribute that can be used to automatically add some specific header to all outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates the header attribute with the given key and value
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Key">
            <summary>
            Gets the key of the header
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Value">
            <summary>
            Gets the value of the header
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that writes saga data snapshots as JSON text to a directory in the file system
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage which will write saga data snapshots to files using file names on the form "ID-REVISION.json"
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Initialize">
            <summary>
            Initializes the file system-based saga snapshot storage by ensuring that the snapshot directory exists and
            making sure that it's writable
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions">
            <summary>
            Configuration extensions for the <see cref="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String)">
            <summary>
            Configures Rebus to use JSON files to store snapshots of saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that uses a table in SQL Server to store saga snapshots
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineMessageContextExtensions">
            <summary>
            Extensions for the message context 
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineMessageContextExtensions.AbortDispatch(Rebus.Pipeline.IMessageContext)">
            <summary>
            Aborts the current message processing pipeline by making the currently executing handler the last one.
            This means that any message handlers following the current one in the current pipeline will NOT be executed.
            If no errors occurred, the queue transaction will be committed as if everything is allright.
            This method can be used to ABORT message process to allow for a handler to FUNCTION AS A FILTER.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepRemover">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can remove steps based on a predicate
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipeline">
            <summary>
            Models a pipeline of steps that will be executed for each sent/received message respectively
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.SendPipeline">
            <summary>
            Gets the send pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> implementations that will be executed for each outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> implementations that will be executed for each incoming message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the pipeline step remover, wrapping the given pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.SendPipeline">
            <summary>
            Gets the outgoing steps from the wrapped pipeline, unless those where one of the registered outgoing step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.ReceivePipeline">
            <summary>
            Gets the incoming steps from the wrapped pipeline, unless those where one of the registered incoming step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveIncomingStep(System.Func{Rebus.Pipeline.IIncomingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching incoming steps to be removed from the pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveOutgoingStep(System.Func{Rebus.Pipeline.IOutgoingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching outgoing steps to be removed from the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AutoHeadersOutgoingStep">
            <summary>
            Outgoing step that picks up <see cref="T:Rebus.Messages.HeaderAttribute"/> from the message type, automatically adding headers
            with <see cref="P:Rebus.Messages.HeaderAttribute.Key"/> set to <see cref="P:Rebus.Messages.HeaderAttribute.Value"/> if a header with such key has not already been added.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AutoHeadersOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out the auto-header logic
            </summary>
        </member>
        <member name="T:Rebus.Legacy.LegacySubscriptionMessagesBinder">
            <summary>
            Type binder for JSON.NET that maps old Rebus' SubscriptionMessage to <see cref="T:Rebus.Legacy.LegacySubscriptionMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Legacy.LegacyCompatibilityConfigurationExtensions">
            <summary>
            Configuration extensions for enabling legacy compatibility
            </summary>
        </member>
        <member name="M:Rebus.Legacy.LegacyCompatibilityConfigurationExtensions.EnableLegacyCompatibility(Rebus.Config.OptionsConfigurer)">
            <summary>
            Makes Rebus "legacy compatible", i.e. enables wire-level compatibility with older Rebus versions. WHen this is enabled,
            all endpoints need to be old Rebus endpoints or new Rebus endpoints with this feature enabled
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that stores subscriptions in a JSON file. Access to the file is synchronized within the process with a <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            </summary>
        </member>
        <member name="T:Rebus.Subscriptions.ISubscriptionStorage">
            <summary>
            Abstraction that handles how subscriptions are stored
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.#ctor(System.String)">
            <summary>
            Constructs the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.Finalize">
            <summary>
            Last-resort disposal of the <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all subscribers of the given topic from the JSON file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber to the list of subscribers from the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber from the list of subscribers of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.Dispose(System.Boolean)">
            <summary>
            Releases the reader/writer lock held by the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.ReaderWriterLockSlim"/> that guards access to the file
            </summary>
        </member>
        <member name="P:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized (which it shouldn't be - that would probably cause some pretty nasty locking exceptions!)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions">
            <summary>
            Configurations extensions for configuring Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String)">
            <summary>
            Configures Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineAbsolutePosition">
            <summary>
            Indicates an absolute position in the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Front">
            <summary>
            Denotes the front of the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Back">
            <summary>
            Denotes the back of the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineCache">
            <summary>
            Cache that can be used as the outermost decorator in order to avoid contantly running any pipeline step injection logic
            that might be configured
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepConcatenator">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can concatenate steps to either pipeline at the front or at the back
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the concatenator
            </summary>
            <param name="pipeline"></param>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified outgoing <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified receive <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.SendPipeline">
            <summary>
            Gets the send pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.ReceivePipeline">
            <summary>
            Gets the receive pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepInjector">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can inject one or more steps into either pipeline,
            positionint the injected steps relatively to another step by its type.
            Could probably be extended with more ways of detecting "the other step" than by its concrete type.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the step injector, wrapping the given <see cref="T:Rebus.Pipeline.IPipeline"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.SendPipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that makes up the outgoing pipeline, injecting any configured outgoing steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.ReceivePipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> that makes up the incoming pipeline, injecting any configured incoming steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IOutgoingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IIncomingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineRelativePosition">
            <summary>
            Indicates in which way a position is related to another step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.Before">
            <summary>
            Indicates that the step must be positioned before the other step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.After">
            <summary>
            Indicates that the step must be positioned after the other step
            </summary>
        </member>
        <member name="T:Rebus.Compression.UnzipMessagesIncomingStep">
            <summary>
            Unzips incoming messages if they're equipped with the <see cref="F:Rebus.Messages.Headers.ContentEncoding"/> header
            (currently only handles the <see cref="F:Rebus.Compression.ZipMessagesOutgoingStep.GzipEncodingHeader"/> type of content encoding)
            </summary>
        </member>
        <member name="M:Rebus.Compression.UnzipMessagesIncomingStep.#ctor(Rebus.Compression.Zipper)">
            <summary>
            Message pipeline step that unzips incoming messages if the <see cref="F:Rebus.Messages.Headers.ContentEncoding"/> is present
            </summary>
        </member>
        <member name="M:Rebus.Compression.UnzipMessagesIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Decompresses the body of the incoming <see cref="T:Rebus.Messages.TransportMessage"/> if it has the <see cref="F:Rebus.Messages.Headers.ContentEncoding"/> header
            set to an understood content encoding
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipConfigurationExtensions">
            <summary>
            Configuration extensions for enabling compression
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes">
            <summary>
            Default threshold for the body size for compression to kick in
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)">
            <summary>
            Enables compression of outgoing messages if the size exceeds the specified number of bytes
            (defaults to <see cref="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes"/>)
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipMessagesOutgoingStep">
            <summary>
            Outgoing step that can be inserted in order to compress the message body of outgoing messages when their length
            exceeds a configurable value
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipMessagesOutgoingStep.GzipEncodingHeader">
            <summary>
            Header value used when the contents is encoded with gzip
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipMessagesOutgoingStep.#ctor(Rebus.Compression.Zipper,System.Int32)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipMessagesOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Compresses theo outgoing transport message body
            </summary>
        </member>
        <member name="T:Rebus.Compression.Zipper">
            <summary>
            Zipper that holds the zipping logic
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Zip(System.Byte[])">
            <summary>
            Zips the byte array
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Unzip(System.Byte[])">
            <summary>
            Unzips the byte array
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusLoggingConfigurer">
            <summary>
            Configurer that is used to configure logging. This configurer is cheating a little bit because it will actually modify a global logger which will
            be used throughout all Rebus instances. This mechanism might change in the future
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Console(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to stdout, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.ColoredConsole(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to with different colors depending on the log level, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Trace">
            <summary>
            Configures Rebus to log its stuff to <see cref="T:System.Diagnostics.Trace"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.None">
            <summary>
            Disables logging alltogether
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Use(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Configures this Rebus instance to use the specified logger factory
            </summary>
        </member>
        <member name="T:Rebus.Extensions.TypeExtensions">
            <summary>
            Provides extensions of <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetBaseTypes(System.Type)">
            <summary>
            Gets the type's base types (i.e. the <see cref="T:System.Type"/> for each implemented interface and for each class inherited from, all the way up to <see cref="T:System.Object"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetSimpleAssemblyQualifiedName(System.Type)">
            <summary>
            Gets the assembly-qualified name of the type, without any version info etc.
            E.g. "System.String, mscorlib"
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.Ignorant">
            <summary>
            Helps keeping track of errors that we want to ignore for a while before acknowledging them
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.#ctor(System.Func{System.Exception,System.String})">
            <summary>
            Constructs the ignorant with the given mapping from an exception instance to the equality key that will be used to compare with previous exceptions.
            If no equality key mapper is given, it will default to using <see cref="P:System.Type.FullName"/> of the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.IsToBeIgnored(System.Exception)">
            <summary>
            Checks whether the given exception is to be ignored
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.Reset">
            <summary>
            Resets the silence period tracker - should be called after each success
            </summary>
        </member>
        <member name="P:Rebus.Exceptions.Ignorant.SilencePeriods">
            <summary>
            Gets/sets the silence periods, i.e. the length of the intervals in which the ignorant will be silent
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions">
            <summary>
            Configuration extensions for setting up an order of handlers that must be respected when
            two or more of the handlers are present in the same handler pipeline
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)">
            <summary>
            Initiates the configuration of the handler ordering - call <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> in
            order to specify the handler that will be put first in the pipeline if it is present
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingStep">
            <summary>
            Incoming message step that can reorder handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.#ctor(Rebus.Handlers.Reordering.ReorderingConfiguration)">
            <summary>
            Constructs the step with the given configuration
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Reorders the handler invokers if necessary
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.DbConnectionWrapper">
            <summary>
            Wrapper of <see cref="T:System.Data.SqlClient.SqlConnection"/> that allows for either handling <see cref="T:System.Data.SqlClient.SqlTransaction"/> automatically, or for handling it externally
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.IDbConnection">
            <summary>
            Wrapper of <see cref="T:System.Data.SqlClient.SqlConnection"/> that allows for easily changing how transactions are handled, and possibly how <see cref="T:System.Data.SqlClient.SqlConnection"/> instances
            are reused by various services
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:System.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:System.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction,System.Boolean)">
            <summary>
            Constructs the wrapper, wrapping the given connection and transaction. It must be indicated with <paramref name="managedExternally"/> whether this wrapper
            should commit/rollback the transaction (depending on whether <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete"/> is called before <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Dispose"/>), or if the transaction
            is handled outside of the wrapper
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Finalize">
            <summary>
            Ensures that the wrapper is always disposed
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:System.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:System.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Dispose">
            <summary>
            Finishes the transaction and disposes the connection in order to return it to the connection pool. If the transaction
            has not been committed (by calling <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete"/>), the transaction will be rolled back.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Dispose(System.Boolean)">
            <summary>
            If the transaction is handled externally, nothing is done when the wrapper is disposed. Otherwise, the connection
            is closed and disposed, and the current transaction is rolled back if <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete"/> was not called
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.IDbConnectionProvider">
            <summary>
            SQL Server database connection provider that allows for easily changing how the current <see cref="T:System.Data.SqlClient.SqlConnection"/> is obtained,
            possibly also changing how transactions are handled
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnectionProvider.GetConnection">
            <summary>
            Gets a wrapper with the current <see cref="T:System.Data.SqlClient.SqlConnection"/> inside
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IMessageContext">
            <summary>
            Representation of the current "message context", which is a convenience wrapper that gives access to the current <see cref="T:Rebus.Transport.ITransactionContext"/>
            (which is the outermost context, the one that spans the entire queue receive transaction) and the current
            <see cref="P:Rebus.Pipeline.IMessageContext.IncomingStepContext"/> (which is actually contained in the transaction context).
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IncomingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing incoming messages
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepContext">
            <summary>
            General step context model that encapsulates an object bag that can be used to pass data from step to step when executing a step pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.StepContext.StepContextKey">
            <summary>
            Key reserved for the step context when it is inserted into the current <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(``0)">
            <summary>
            Saves the given instance in the bag with a key derived from the (possibly explicitly specified) type <typeparamref name="T"/> (by calling <see cref="P:System.Type.FullName"/>).
            Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(System.String,``0)">
            <summary>
            Saves the given instance in the bag with the specified key. Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1">
            <summary>
            Loads the instance stored under the key that is stored under a key as determined by calling <see cref="P:System.Type.FullName"/> on the specified type <typeparamref name="T"/>.
            Returns null if none could be found.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1(System.String)">
            <summary>
            Loads the instance stored under the specified key. Returns null if none could be found.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IncomingStepContext.#ctor(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.TransportMessage"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.MessageContext">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IMessageContext"/> that provides the static gateway <see cref="P:Rebus.Pipeline.MessageContext.Current"/> property to get
            the current message context.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Current">
            <summary>
            Gets the current message context from the current <see cref="T:Rebus.Transport.AmbientTransactionContext"/> (accessed by
            <see cref="P:Rebus.Transport.AmbientTransactionContext.Current"/>), returning null if no transaction context was found
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.OutgoingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.OutgoingStepContext.#ctor(Rebus.Messages.Message,Rebus.Transport.ITransactionContext,Rebus.Pipeline.Send.DestinationAddresses)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.Message"/>, list of <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvokers">
            <summary>
            Represents a sequence of handler invokers
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.#ctor(System.Collections.Generic.IEnumerable{Rebus.Pipeline.Receive.HandlerInvoker})">
            <summary>
            Constructs the sequence
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.GetEnumerator">
            <summary>
            Gets all the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/>s that this <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/> contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignDateTimeOffsetHeader">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.SentTime"/> header of the outgoing message to <see cref="P:Rebus.Time.RebusTime.Now"/>
            (serializing it with the "O" format, i.e. its ISO 8601 representation)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDateTimeOffsetHeader.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.SentTime"/> header
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.DestinationAddresses">
            <summary>
            Encapsulates a list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs the list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.GetEnumerator">
            <summary>
            Gets all the addresses that this <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> object contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepDocumentationAttribute">
            <summary>
            Documents the purpose of an <see cref="T:Rebus.Pipeline.IIncomingStep"/> or <see cref="T:Rebus.Pipeline.IOutgoingStep"/> which can then be used by tools to generate nice docs
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepDocumentationAttribute.#ctor(System.String)">
            <summary>
            Creates the attribute with the given documentation test
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.StepDocumentationAttribute.Text">
            <summary>
            Gets the documentation text
            </summary>
        </member>
        <member name="T:Rebus.Retry.ErrorTracking.InMemErrorTracker">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IErrorTracker"/> that tracks errors in an in-mem dictionary
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorTracker">
            <summary>
            Service that is responsible for tracking errors across message deliveries.
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.RegisterError(System.String,System.Exception)">
            <summary>
            This method is called on each experienced failed delivery
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.CleanUp(System.String)">
            <summary>
            This method is called when there's no need to track the error anymore
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether the given message ID has had too many error registered for it
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetShortErrorDescription(System.String)">
            <summary>
            Should get a short error description for the message ID (i.e. something like "5 failed deliveries")
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Should get a full, detailed error description for the message ID (i.e. could be timestamps and full stack traces for all failed deliveries)
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.#ctor(System.Int32,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the in-mem error tracker with the configured number of delivery attempts as the MAX
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Finalize">
            <summary>
            Last-resort disposal of the in-mem error tracker's background cleaning task
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Initialize">
            <summary>
            Initializes the in-mem error tracker - starts a background task that periodically cleans up tracked errors that haven't had any activity for 10 minutes or more
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.RegisterError(System.String,System.Exception)">
            <summary>
            Registers the given <paramref name="exception"/> under the supplied <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether too many errors have been tracked for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetShortErrorDescription(System.String)">
            <summary>
            Gets a short description of the tracked errors for the given <paramref name="messageId"/> on the form
            "n unhandled exceptions"
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Gets a long and detailed description of the tracked errors for the given <paramref name="messageId"/>
            consisting of time and full exception details for all registered exceptions
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.CleanUp(System.String)">
            <summary>
            Cleans up whichever tracking wr have done for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Dispose">
            <summary>
            Stops the periodic cleanup of tracked messages
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Dispose(System.Boolean)">
            <summary>
            Shuts down the background task that removes tracked message IDs where nothing has happened for too long
            </summary>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategyStep">
            <summary>
            Special marker for the retry strategy step
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.Failed`1">
            <summary>
            Wraps a failed message that is to be retried
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.Failed`1.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},`0,System.String)">
            <summary>
            Constructs the wrapper with the given message
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.Failed`1.ToString">
            <summary>
            Returns a string that represents the current failed message
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.Failed`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.Failed`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.Failed`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardAction">
            <summary>
            Represents some action to perform with the incoming transport message. Must be created via the static functions
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ForwardAction.None">
            <summary>
            Gets an action that causes the message to be handled normally
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.ForwardTo(System.String)">
            <summary>
            Gets an action that causes the message to be forwarded to the queue specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardTransportMessageStep">
            <summary>
            Incoming message step that looks at the transport message and possibly forwards it to another queue
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.#ctor(System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}},Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Invokes the routing function and performs some action depending on the returned <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> result
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions">
            <summary>
            Configuration extensions for very fast filtering and forwarding of incoming transport messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions.AddTransportMessageForwarder(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}})">
            <summary>
            Adds the given routing function - should return <see cref="F:Rebus.Routing.TransportMessages.ForwardAction.None"/> to do nothing, or another action
            available on <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> in order to do something to the message
            </summary>
        </member>
        <member name="T:Rebus.Sagas.IAmInitiatedBy`1">
            <summary>
            Derived marker interface, allowing for a handler to indicate that messages of type <typeparamref name="TMessage"/> 
            are allowed to instantiate new saga instances if the message cannot be correlated with an already existing instance
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotencyData">
            <summary>
            This chunk of data help with tracking handled messages and externally visible behavior (i.e. outbound messages) from handling each message
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.HasAlreadyHandled(System.String)">
            <summary>
            Gets whether the message with the given ID has already been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.GetOutgoingMessages(System.String)">
            <summary>
            Gets the outgoing messages for the incoming message with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.MarkMessageAsHandled(System.String)">
            <summary>
            Marks the message with the given ID as handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.AddOutgoingMessage(System.String,System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Adds the <see cref="T:Rebus.Messages.TransportMessage"/> as an outgoing message destined for the addresses specified by <paramref name="destinationAddresses"/>
            under the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.OutgoingMessages">
            <summary>
            Gets the outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.HandledMessageIds">
            <summary>
            Getst the IDs of all messages that have been handled
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSaga`1">
            <summary>
            Sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> are sagas that guarantee idempotency by guarding against
            handling the same message twice by tracking IDs of handled messages
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga`1">
            <summary>
            Generic saga base class that must be made concrete by supplying the <typeparamref name="TSagaData"/> type parameter.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga">
            <summary>
            Saga base class that allows for passing around saga instances without being bothered by the type of saga data they're handling. You should
            probably not inherit from this one, inherit your saga from <see cref="T:Rebus.Sagas.Saga`1"/> instead.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsComplete">
            <summary>
            Marks the current saga instance as completed, which means that it is either a) deleted from persistent storage in case
            it has been made persistent, or b) thrown out the window if it was never persisted in the first place.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsUnchanged">
            <summary>
            Marks the current saga instance as unchanged, causing any changes made to it to be ignored. Its revision will NOT be
            incremented
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga.IsNew">
            <summary>
            Gets whether the saga data instance is new
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.CorrelateMessages(Rebus.Sagas.ICorrelationConfig{`0})">
            <summary>
            This method must be implemented in order to configure correlation of incoming messages with existing saga data instances.
            Use the injected <see cref="T:Rebus.Sagas.ICorrelationConfig`1"/> to set up the correlations, e.g. like so:
            <code>
            config.Correlate&lt;InitiatingMessage&gt;(m =&gt; m.OrderId, d =&gt; d.CorrelationId);
            config.Correlate&lt;CorrelatedMessage&gt;(m =&gt; m.CorrelationId, d =&gt; d.CorrelationId);
            </code>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga`1.Data">
            <summary>
            Gets or sets the relevant saga data instance for this saga handler
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ICorrelationConfig`1">
            <summary>
            Sets up the saga instance correlation configuration, i.e. it configures how the following question should be answered:
            "given this incoming message, how should Rebus figure out which saga instance should be loaded to handle it?"
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.Correlate``1(System.Func{``0,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/>, using the specified <paramref name="messageValueExtractorFunction"/> to
            extract a value from the message. The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            You could for example do something like this:
            <code>
            config.Correlate&lt;TradeApproved&gt;(t =&gt; t.Id, d =&gt; d.TradeId);
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "Id" property of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="messageValueExtractorFunction">Configures a function to extract a value from the message. Since this is just a function, it may contain logic that e.g. concatenates fields, calls other functions, etc.</param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions">
            <summary>
            Configuration extension for the idempotent sagas feature (allows for guaranteeing that a saga instance does not handle the same
            message twice, even in the face of at-least-once delivery guarantees and retries due to transport layer failures)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions.EnableIdempotentSagas(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables idempotent sagas. When enabled, sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> can be truly idempotent.
            This means that the saga instance stores the IDs of all handled messages, including all outgoing messages send when handling
            each incoming message - this way, the saga instance can guard itself against handling the same message twice, while still
            preserving externally visible behavior even when a message gets handled more than once.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaData">
            <summary>
            Convenient standard implementation of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaData">
            <summary>
            Convenient implementation of <see cref="T:Rebus.Sagas.ISagaData"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaData">
            <summary>
            Interface of a saga data instance. The saga data represents the state of the state machine instance of the process manager,
            that the saga essentially implements.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IIdempotentSagaData">
            <summary>
            Derivation of <see cref="T:Rebus.Sagas.ISagaData"/> that is capable of storing externally visible side-effects (i.e. outgoing messages)
            that were caused by handling specific incoming messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IIdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep">
            <summary>
            Incoming pipeline step that checks the loaded saga data to see if the message currently being handled is a dupe.
            If it is, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message
            will be sent 
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks the loaded saga data to see if the message currently being handled is a duplicate of a message that has previously been handled. 
            If that is the case, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message will be sent.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep">
            <summary>
            Outgoing pipeline step that stores the sent message in the current saga data (if it is an <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessage">
            <summary>
            An outgoing message is a <see cref="T:Rebus.Messages.TransportMessage"/> destined for one or more destinations. It is meant to be stored
            in an <see cref="T:Rebus.Sagas.Idempotent.IdempotencyData"/> instance inside an instance of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessage.#ctor(System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the outgoing message destined for the given addresses
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.DestinationAddresses">
            <summary>
            Gets the addresses for which this <see cref="T:Rebus.Messages.TransportMessage"/> is supposed to be sent
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.TransportMessage">
            <summary>
            Gets the transport message
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessages">
            <summary>
            Contains all the <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances for a given incoming message
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.#ctor(System.String,System.Collections.Generic.IEnumerable{Rebus.Sagas.Idempotent.OutgoingMessage})">
            <summary>
            Constructs the instance for the given message ID, containing the given <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.Add(Rebus.Sagas.Idempotent.OutgoingMessage)">
            <summary>
            Adds another <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> as a side-effect of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId">
            <summary>
            Gets the ID of the incoming message
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessagesToSend">
            <summary>
            Gets all the outgoing messages to be sent as a consequence of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaCorrelationProperty">
            <summary>
            Represents a path to a correlation property on a saga of a specific type
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga data
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaDataCorrelationProperties">
            <summary>
            Contains a set of correlation properties relevant for one particular saga data
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.#ctor(System.Collections.Generic.Dictionary{System.Type,Rebus.Sagas.CorrelationProperty[]},System.Type)">
            <summary>
            Constructs the set
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.ForMessage(System.Object)">
            <summary>
            Looks up correlation properties relevant for the specified message type
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.GetEnumerator">
            <summary>
            Gets the correlation properties contained in this collection
            </summary>
        </member>
        <member name="T:Rebus.Serialization.DictionarySerializer">
            <summary>
            Generic serializer that serializes <see cref="T:System.Collections.Generic.Dictionary`2"/> of <see cref="T:System.String"/> keys and <see cref="T:System.String"/> values
            into JSON and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.SerializeToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Serializes the given dictionary into a JSON string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.DeserializeFromString(System.String)">
            <summary>
            Deserializes the given JSON string into a dictionary
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ObjectSerializer">
            <summary>
            Generic serializer that happily serializes rich objects. Uses JSON.NET internally with full type information.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Serialize(System.Object)">
            <summary>
            Serializes the given object into a byte[]
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes the given byte[] into an object
            </summary>
        </member>
        <member name="T:Rebus.Threading.AsyncBottleneck">
            <summary>
            The "bottleneck" is a wrapper around <see cref="T:System.Threading.SemaphoreSlim"/> that makes it easy to decrese the count of a semaphore,
            increasing it again after having used it.
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.#ctor(System.Int32)">
            <summary>
            Constructs the bottleneck, allowing for <paramref name="maxParallelOperationsToAllow"/> parallel operations
            to be performed
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.Enter">
            <summary>
            Grabs the semaphore and releases an <see cref="T:System.IDisposable"/> that will release it again when disposed
            </summary>
        </member>
        <member name="T:Rebus.Threading.AsyncTask">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/>-based background timer thingie, that will periodically call an async <see cref="T:System.Func`1"/>
             </summary>
        </member>
        <member name="F:Rebus.Threading.AsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.AsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.AsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncTask.Finalize">
            <summary>
            Last-resort shutdown of the task (if it wasn't properly disposed)
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncTask.Dispose(System.Boolean)">
            <summary>
            Cancels the background task so that it stops, waiting (up to 5 seconds) until it has exited properly
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:Rebus.Threading.AsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.AsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager">
            <summary>
            Helper that counts the number of parallel operations. Not reentrant, this bad boy is meant to be used from a single worker thread
            that may use it to count the number of async parallel operations waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.#ctor(System.Int32)">
            <summary>
            Constructs the container with the given max number of parallel async operations to allow
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.TryBegin">
            <summary>
            Begins another async operation and returns an <see cref="T:System.IDisposable"/> that must be disposed in order to mark the end of the async operation
            </summary>
        </member>
        <member name="P:Rebus.Threading.ParallelOperationsManager.HasPendingTasks">
            <summary>
            Gets whether any async tasks are currently waiting to be completed
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager.ParallelOperation">
            <summary>
            Gets a disposable token for the parallel operation - the token indicates whether it's ok to continue
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.Dispose">
            <summary>
            Ends this parallel operation
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.CanContinue">
            <summary>
            Gets whether the token was successfully acquired
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessage">
            <summary>
            Represents a message that was deferred and is now due. The message has some headers and a body and can be turned into
            a <see cref="T:Rebus.Messages.TransportMessage"/> by calling <see cref="M:Rebus.Timeouts.DueMessage.ToTransportMessage"/>. The due message can be constructed in a
            way that can perform an arbitrary action in order to mark the due message as successfully delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[],System.Action)">
            <summary>
            Constructs the due message with the given headers and body, storing the given <paramref name="completeAction"/> to be
            executed when the message's <see cref="M:Rebus.Timeouts.DueMessage.MarkAsCompleted"/> method is called.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.MarkAsCompleted">
            <summary>
            Marks the due message as successfully handled, which should probably be done when the message has been safely sent to the proper recipient
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.ToTransportMessage">
            <summary>
            Returns the headers and the body of this due message in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Headers">
            <summary>
            Gets the headers of this due message
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Body">
            <summary>
            Gets the body data of this due message
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessagesResult">
            <summary>
            Represents the result of calling <see cref="M:Rebus.Timeouts.ITimeoutManager.GetDueMessages"/> - contains zero or mode <see cref="T:Rebus.Timeouts.DueMessage"/> objects
            where each due message can be individually marked as successfully delivered 
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.#ctor(System.Collections.Generic.IEnumerable{Rebus.Timeouts.DueMessage},System.Action)">
            <summary>
            Constructs the result, wrapping the given list of due messages, performing the given action when the instance is disposed
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.Dispose">
            <summary>
            Invokes the cleanup action
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.GetEnumerator">
            <summary>
            Returns all due messages from this result
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessagesResult.Empty">
            <summary>
            Gets an empty due messages result
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.ITimeoutManager">
            <summary>
            Abstraction for a mechanism that is capable of storing deferred messages until the time where it's appropriate for it to be delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.ITimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Time.RebusTimeMachine">
            <summary>
            Test utility that makes it easy to fake the time returned by <see cref="T:Rebus.Time.RebusTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Time.RebusTimeMachine.FakeIt(System.DateTimeOffset,System.Boolean)">
            <summary>
            Fakes the current time to the time specified, making slight increments in time for each invocation
            (the slight increments can be turned off by setting <paramref name="incrementSlightlyOnEachInvocation"/> to false)
            </summary>
        </member>
        <member name="M:Rebus.Time.RebusTimeMachine.Reset">
            <summary>
            Resets the time factory back to returning the real time
            </summary>
        </member>
        <member name="T:Rebus.Transport.AmbientTransactionContext">
            <summary>
            Provides an "ambient" context for stashing away an instance that implements the current <see cref="T:Rebus.Transport.ITransactionContext"/>. The
            ambient transaction context is automatically preserved even though threads are changed etc.
            </summary>
        </member>
        <member name="P:Rebus.Transport.AmbientTransactionContext.Current">
            <summary>
            Gets/sets the current transaction context from the call context's logical data slot (which is automatically transferred to continuations when resuming
            awaited calls)
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransport">
            <summary>
            Transport implementation that uses the file system to send/receive messages.
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransport">
            <summary>
            The transport is responsible for sending and receiving messages
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.CreateQueue(System.String)">
            <summary>
            Must create a queue with the given address
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given <see cref="T:Rebus.Messages.TransportMessage"/> to the queue with the specified globally addressable name
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.Receive(Rebus.Transport.ITransactionContext)">
            <summary>
            Receives the next message (if any) from the transport's input queue <see cref="P:Rebus.Transport.ITransport.Address"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.ITransport.Address">
            <summary>
            Gets the global address of the transport's input queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.#ctor(System.String,System.String)">
            <summary>
            Constructs the file system transport to create "queues" as subdirectories of the specified base directory.
            While it is apparent that <seealso cref="F:Rebus.Transport.FileSystem.FileSystemTransport._baseDirectory"/> must be a valid directory name, please note that 
            <seealso cref="F:Rebus.Transport.FileSystem.FileSystemTransport._inputQueue"/> must not contain any invalid path either.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.CreateQueue(System.String)">
            <summary>
            Creates a "queue" (i.e. a directory) with the given name
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the specified message to the logical queue specified by <paramref name="destinationQueueName"/> by writing
            a JSON serialied text to a file in the corresponding directory. The actual write operation is delayed until
            the commit phase of the queue transaction unless we're non-transactional, in which case it is written immediately.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Receive(Rebus.Transport.ITransactionContext)">
            <summary>
            Receives the next message from the logical input queue by loading the next file from the corresponding directory,
            deserializing it, deleting it when the transaction is committed.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Initialize">
            <summary>
            Ensures that the "queue" is initialized (i.e. that the corresponding subdirectory exists).
            </summary>
        </member>
        <member name="P:Rebus.Transport.FileSystem.FileSystemTransport.Address">
            <summary>
            Gets the logical input queue name which for this transport correponds to a subdirectory of the specified base directory.
            For other transports, this is a global "address", but for this transport the address space is confined to the base directory.
            Therefore, the global address is the same as the input queue name.
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the file system transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions.UseFileSystem(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String)">
            <summary>
            Configures Rebus to use the file system to transport messages. The specified <paramref name="baseDirectory"/> will be used as the base directory
            within which subdirectories will be created for each logical queue.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions.UseFileSystemAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String)">
            <summary>
            Configures Rebus to use the file system to transport messages, as a one-way client. The specified <paramref name="baseDirectory"/> will be used as the base directory
            within which subdirectories will be created for each logical queue.
            </summary>
        </member>
        <member name="T:Rebus.Transport.TransactionContextExtensions">
            <summary>
            Nifty extensions to the transaction context, mostly working on the <see cref="P:Rebus.Transport.ITransactionContext.Items"/> dictionary
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrNull``1(Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrThrow``1(Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrAdd``1(Rebus.Transport.ITransactionContext,System.String,System.Func{``0})">
            <summary>
            Provides a shortcut to the transaction context's <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>,
            only as a typed version that 
            </summary>
        </member>
        <member name="T:Rebus.Workers.IWorker">
            <summary>
            Represents a worker, which is a thing that is capable of doing work. It may correspond to a worker thread
            if the usual Rebus worker threads are used, but it may be possible to do other stuff as well
            </summary>
        </member>
        <member name="M:Rebus.Workers.IWorker.Stop">
            <summary>
            Signals that the worker should try to stop itself because it will be thrown out and disposed in a little while
            </summary>
        </member>
        <member name="P:Rebus.Workers.IWorker.Name">
            <summary>
            Gets the name of the worker. Each worker will be named so that they can be recognized
            </summary>
        </member>
        <member name="T:Rebus.Bus.MessageExtensions">
            <summary>
            Small helpers that make it easier to work with the <see cref="T:Rebus.Messages.Message"/> class
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.HasReturnAddress(Rebus.Messages.Message)">
            <summary>
            Gets whether the message's <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to something
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetReturnAddressFromTransport(Rebus.Messages.Message,Rebus.Transport.ITransport)">
            <summary>
            Uses the transport's input queue address as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> on the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeader(Rebus.Messages.Message,System.DateTimeOffset)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeader(Rebus.Messages.TransportMessage,System.DateTimeOffset)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.Message)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.Message)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.Message)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.TransportMessage)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.Clone(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a cloned instance of the transport message
            </summary>
        </member>
        <member name="T:Rebus.Backoff.SimpleConstantPollingBackoffStrategy">
            <summary>
            Simple constant polling strategy
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleConstantPollingBackoffStrategy.Wait">
            <summary>
            Asynchronously executes the next wait operation, possibly advancing the wait cursor to a different wait time for the next time
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleConstantPollingBackoffStrategy.Reset">
            <summary>
            Resets the wait cursor, ensuring that the next wait operation will start over
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadBased.ThreadWorker">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorker"/> that has a dedicated thread the continuously polls the given <see cref="T:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext"/> for work,
            and in case it doesn't find any, it'll try to receive a new message and invoke a receive pipeline on that
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorker.Finalize">
            <summary>
            Disposes any unmanaged held resources
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorker.Stop">
            <summary>
            Stops this thread worker
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorker.Dispose">
            <summary>
            Stops the thread worker, waiting for it to finish whatever it was doing (up to 5 seconds)
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorker.Dispose(System.Boolean)">
            <summary>
            Ensures that the worker thread is stopped and waits for it to exit
            </summary>
        </member>
        <member name="P:Rebus.Workers.ThreadBased.ThreadWorker.Name">
            <summary>
            Gets the name of this thread worker
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext">
            <summary>
            Derivation of <see cref="T:System.Threading.SynchronizationContext"/> that queues posted callbacks, allowing for worker threads to retrieve them later 
            on as a simple, callable <see cref="T:System.Action"/>, by calling <see cref="M:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext.GetNextContinuationOrNull"/>
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            This method is called when a <see cref="T:System.Threading.Tasks.Task"/> has finished and is ready to be continued
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext.GetNextContinuationOrNull">
            <summary>
            Gets the next ready continuation if any, returns null otherwise
            </summary>
        </member>
        <member name="T:Rebus.Config.Configure">
            <summary>
            Configuration entry point - call the static <see cref="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)"/> method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> 
            (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)">
            <summary>
            Call this method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one 
            that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="T:Rebus.Config.Options">
            <summary>
            Contains additional options for configuring Rebus internals
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultNumberOfWorkers">
            <summary>
            This is the default number of workers that will be started, unless <see cref="P:Rebus.Config.Options.NumberOfWorkers"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultMaxParallelism">
            <summary>
            This is the default number of concurrent asynchrounous operations allowed, unless <see cref="P:Rebus.Config.Options.MaxParallelism"/> is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Config.Options.#ctor">
            <summary>
            Constructs the options with the default settings
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.NumberOfWorkers">
            <summary>
            Configures the number of workers. If thread-based workers are used, this is the number of threads that will be created.
            This number should be less than or equal to <see cref="P:Rebus.Config.Options.MaxParallelism"/>.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.MaxParallelism">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.ExternalTimeoutManagerAddressOrNull">
            <summary>
            Gets/sets the address to use if an external timeout manager is to be used
            </summary>
        </member>
        <member name="T:Rebus.Config.OptionsConfigurer">
            <summary>
            Allows for configuring additional options
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetNumberOfWorkers(System.Int32)">
            <summary>
            Configures the number of workers to start competing over the input queue
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetMaxParallelism(System.Int32)">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.UseExternalTimeoutManager(System.String)">
            <summary>
            Configures Rebus to use another endpoint as the timeout manager
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0})">
            <summary>
            Registers the given factory function as a resolver of the given primary implementation of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0})">
            <summary>
            Registers the given factory function as a resolve of the given decorator of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.LogPipeline(System.Boolean)">
            <summary>
            Outputs the layout of the send and receive pipelines to the log
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusConfigurer">
            <summary>
            Basic skeleton of the fluent configuration builder. Contains a method for each aspect that can be configured
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Logging(System.Action{Rebus.Config.RebusLoggingConfigurer})">
            <summary>
            Configures how Rebus logs things that happen by installing a <see cref="T:Rebus.Logging.RebusLoggerFactory"/> instance
            on <see cref="P:Rebus.Logging.RebusLoggerFactory.Current"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})">
            <summary>
            Configures how Rebus sends/receives messages by allowing for choosing which implementation of <see cref="T:Rebus.Transport.ITransport"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Routing(System.Action{Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter}})">
            <summary>
            Configures how Rebus routes messages by allowing for choosing which implementation of <see cref="T:Rebus.Routing.IRouter"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Sagas(System.Action{Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage}})">
            <summary>
            Configures how Rebus persists saga data by allowing for choosing which implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Subscriptions(System.Action{Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage}})">
            <summary>
            Configures how Rebus persists subscriptions by allowing for choosing which implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Serialization(System.Action{Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer}})">
            <summary>
            Configures how Rebus serializes messages by allowing for choosing which implementation of <see cref="T:Rebus.Serialization.ISerializer"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Timeouts(System.Action{Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager}})">
            <summary>
            Configures how Rebus defers messages to the future by allowing for choosing which implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Options(System.Action{Rebus.Config.OptionsConfigurer})">
            <summary>
            Configures additional options about how Rebus works
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Start">
            <summary>
            Finishes the setup of the bus, using default implementations for the options that have not explicitly been set.
            The only requirement, is that you must call <see cref="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})"/> and select which transport to use - everything
            else can run with a default option. It should be noted though, that several of the defaults (e.g. in-mem persistence
            options for saga storage, subscriptions, and timeouts) are not meant for production use, and should probably be
            replaced by something that is actually persistent.
            </summary>
        </member>
        <member name="T:Rebus.Config.StandardConfigurer`1">
            <summary>
            Configurer that can have extension methods attached to it for helping with registering an implementation or a decorator
            for the <typeparamref name="TService"/> service.
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Register(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Decorate(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.OtherService``1">
            <summary>
            Gets a typed configurer for another service. Can be useful if e.g. a configuration extension for a <see cref="T:Rebus.Transport.ITransport"/>
            wants to replace the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> because it is capable of using the transport layer to do pub/sub
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.ConcurrencyException">
            <summary>
            Special exception that signals that some kind of optimistic lock has been violated, and work must most likely be aborted &amp; retried
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Extensions.EnumerableExtensions">
            <summary>
            Nifty extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/> 
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/>, checking equality with the given <paramref name="equalityComparer"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Iterates the sequence, calling the given <paramref name="itemAction"/> for each item
            </summary>
        </member>
        <member name="T:Rebus.Handlers.InternalHandlersContributor">
            <summary>
            Decoration of <see cref="T:Rebus.Activation.IHandlerActivator"/> that adds a few special handlers when an incoming message can be recognized
            as a special Rebus message
            </summary>
        </member>
        <member name="M:Rebus.Handlers.InternalHandlersContributor.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Gets Rebus' own internal handlers (if any) for the given message type
            </summary>
        </member>
        <member name="T:Rebus.Injection.Injectionist">
            <summary>
            Dependency injectionist that can be used for configuring a system of injected service implementations, possibly with decorators,
            with caching of instances so that the same instance of each class is used throughout the tree. Should probably not be used for
            anything at runtime, is only meant to be used in configuration scenarios.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Get``1">
            <summary>
            Starts a new resolution context, resolving an instance of the given <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a factory method that can provide an instance of the primary implementation of <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a factory method that can provide a decorator of <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Has``1">
            <summary>
            Returns whether there exists a primary registration for the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="E:Rebus.Injection.Injectionist.ResolveRequested">
            <summary>
            Event that gets fired when (top level) resolve is called for a type
            </summary>
        </member>
        <member name="T:Rebus.Injection.IResolutionContext">
            <summary>
            Represents the context of resolving one root service and can be used throughout the tree to fetch something to be injected
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Get``1">
            <summary>
            Gets an instance of the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.GetTrackedInstancesOf``1">
            <summary>
            Gets all instances resolved within this resolution context at this time.
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionException">
            <summary>
            Exceptions that is thrown when something goes wrong while working with the injectionist
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Logging.AbstractRebusLoggerFactory">
            <summary>
            If you intend to implement your own logging, you probably want to derive
            from this class and implement <seealso cref="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Rebus.Logging.IRebusLoggerFactory">
            <summary>
            Basic interface of a Rebus logger factory. If you intend to implement your own,
            <see cref="T:Rebus.Logging.AbstractRebusLoggerFactory"/> is the one to derive from - you should
            probably not implement this interface directly.
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetLogger``1">
            <summary>
            Gets a logger for the type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)">
            <summary>
            Should get a logger for the specified type 
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger``1">
            <summary>
            Gets a logger for the type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:Rebus.Logging.ColorSetting">
            <summary>
            Represents a console color setting consisting of a foreground and a background color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Foreground(System.ConsoleColor)">
            <summary>
            Sets the foreground color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Background(System.ConsoleColor)">
            <summary>
            Sets the background color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Enter">
            <summary>
            Sets the current console colors to those specified in this <see cref="T:Rebus.Logging.ColorSetting"/>,
            restoring them to the previous colors when disposing
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.ForegroundColor">
            <summary>
            Gets the foreground color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.BackgroundColor">
            <summary>
            Gets the background color
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory">
            <summary>
            Logger factory that logs stuff to the console
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.#ctor(System.Boolean)">
            <summary>
            Constructs the logger factory
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a logger for logging stuff from within the specified type
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Colors">
            <summary>
            Gets or sets the colors to use when logging
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.MinLevel">
            <summary>
            Gets or sets the minimum logging level to output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Filters">
            <summary>
            Gets the list of filters that each log statement will be passed through in order to evaluate whether
            the given log statement should be output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.ShowTimestamps">
            <summary>
            Gets/sets whether timestamps should be shown when logging
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory.LogStatement">
            <summary>
            One single log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Level">
            <summary>
            The level of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Text">
            <summary>
            The text (possibly inclusing formatting placeholders) of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Args">
            <summary>
            The values to use for string interpolation
            </summary>
        </member>
        <member name="T:Rebus.Logging.ILog">
            <summary>
            Interface of a Rebus logger
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Debug(System.String,System.Object[])">
            <summary>
            Writes the specified message with the DEBUG level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Info(System.String,System.Object[])">
            <summary>
            Writes the specified message with the INFO level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level
            </summary>
        </member>
        <member name="T:Rebus.Logging.GhettoFileLoggerFactory">
            <summary>
            Crude file logger implementation
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.#ctor(System.String)">
            <summary>
            Creates a crude file-logging thingie, that will flush to the specified file every 500 ms
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.WithFilter(System.Func{Rebus.Logging.GhettoFileLoggerFactory.LogMessage,System.Boolean})">
            <summary>
            Adds the specified filter predicate function to the list of filters that will be evaluated for each log message,
            determining whether or not the given message will end up in the file
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.Finalize">
            <summary>
            Ensure, in the most hackish way possible, that the buffer is flushed to disk and that the background flush timer is stopped
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.GhettoFileLoggerFactory.CrudeFileLogger"/> to log yo stuff good
            </summary>
        </member>
        <member name="T:Rebus.Logging.GhettoFileLoggerFactory.LogMessage">
            <summary>
            Model of a log message that has been queued to be flushed to disk later
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.LoggerType">
            <summary>
            Indicates the type from which the logger that created the log message was created
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.Time">
            <summary>
            The time when this log message was emitted
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.Message">
            <summary>
            The log message
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.Level">
            <summary>
            The log level
            </summary>
        </member>
        <member name="T:Rebus.Logging.LoggingColors">
            <summary>
            Represents a set of colors to be used by the <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> when running
            in colored mode
            </summary>
        </member>
        <member name="M:Rebus.Logging.LoggingColors.#ctor">
            <summary>
            Constructs the default set of logging colors, which if gray, green, yellow, and red foreground for log
            levels debug, info, warn, and error respectively.
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Debug">
            <summary>
            Gets/sets the color to use when printing DEBUG log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Info">
            <summary>
            Gets/sets the color to use when printing INFO log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Warn">
            <summary>
            Gets/sets the color to use when printing WARN log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Error">
            <summary>
            Gets/sets the color to use when printing ERROR log statements
            </summary>
        </member>
        <member name="T:Rebus.Logging.LogLevel">
            <summary>
            Enumeration of the log levels available with Rebus loggers. As a general rule of thumb, levels WARN
            and ERROR should, as a minimum, ALWAYS be logged to a local file or another persistent means.
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Debug">
            <summary>
            Log statement of very low importance which is most likely only relevant in extreme debugging scenarios
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Info">
            <summary>
            Log statement of low importance to unwatched running systems which however can be very relevant when testing and debugging
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Warn">
            <summary>
            Log statement of fairly high importance - always contains relevant information on somewhing that may be a sign that something is wrong
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Error">
            <summary>
            Log statement of the highest importance - always contains relevant information on something that has gone wrong
            </summary>
        </member>
        <member name="T:Rebus.Logging.NullLoggerFactory">
            <summary>
            This is the /dev/null of loggers...
            </summary>
        </member>
        <member name="M:Rebus.Logging.NullLoggerFactory.GetLogger(System.Type)">
            <summary>
            Returns a <see cref="T:Rebus.Logging.NullLoggerFactory.NullLogger"/> which is the /dev/null of logging...
            </summary>
        </member>
        <member name="T:Rebus.Logging.RebusLoggerFactory">
            <summary>
            Static gateway that can be used by Rebus components to enlist in the logging framework
            </summary>
        </member>
        <member name="M:Rebus.Logging.RebusLoggerFactory.Reset">
            <summary>
            Resets the current implementation of <see cref="T:Rebus.Logging.IRebusLoggerFactory"/> back to the default, which is a
            <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> with colors turned ON
            </summary>
        </member>
        <member name="E:Rebus.Logging.RebusLoggerFactory.Changed">
            <summary>
            Event that is raised when the global implementation of <see cref="T:Rebus.Logging.IRebusLoggerFactory"/> is changed to something else.
            Note that the event is also raised immediately for each particular subscriber when they subscribe.
            </summary>
        </member>
        <member name="P:Rebus.Logging.RebusLoggerFactory.Current">
            <summary>
            Gets the currently configured implementation of <see cref="T:Rebus.Logging.IRebusLoggerFactory"/>. The instance is global for the
            entire AppDomain
            </summary>
        </member>
        <member name="T:Rebus.Logging.TraceLoggerFactory">
            <summary>
            Logger factory that writes log statements using the <see cref="T:System.Diagnostics.Trace"/> API
            </summary>
        </member>
        <member name="M:Rebus.Logging.TraceLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.TraceLoggerFactory.TraceLogger"/>
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.SubscribeRequest">
            <summary>
            Control message that can be used to establish a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to enlist for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.Topic">
            <summary>
            Specifis the topic for which the subscriber wishes to subscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.UnsubscribeRequest">
            <summary>
            Control message that can be used to end a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to remove for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.Topic">
            <summary>
            Specifis the topic from which the subscriber wishes to unsubscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers">
            <summary>
            Contains keys of headers known &amp; used by Rebus
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.MessageId">
            <summary>
            Id of the message. Either set the ID explicitly when sending a message, or Rebus will assign one to the message.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Type">
            <summary>
            .NET type (if possible) of the sent message 
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationId">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get the correlation ID (or the message ID
            if there's no correlation ID) of the handled message copied to it. When a message is initially sent, its correlation ID
            will be its own message ID.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ReturnAddress">
            <summary>
            The return address of the message, i.e. the address that repliers must reply to.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentType">
            <summary>
            Describes the contents of the message with a type and an encoding
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentEncoding">
            <summary>
            Optional header element that specifies an encoding that the content is encoded with, e.g. gzip
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ErrorDetails">
            <summary>
            Details that can be attached to a message that is forwarded after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SourceQueue">
            <summary>
            Source queue of a message the has bee forwarded to an error queue after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredUntil">
            <summary>
            Indicates that the message must not be consumed right away, delivery should be delayed until the specified time
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.TimeToBeReceived">
            <summary>
            Indicates a time span (as a string, on the form hh:MM:ss) after which the queueing system can safely delete the message and thus never deliver it
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Express">
            <summary>
            Header that indicates that the queueing system can trade reliability for performance in order to deliver this message as fast as possible
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SentTime">
            <summary>
            Headers with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message was sent.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Intent">
            <summary>
            Header that indicates whether this message was sent or published
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers.IntentOptions">
            <summary>
            Contains the possible values for the <see cref="F:Rebus.Messages.Headers.Intent"/> header
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PointToPoint">
            <summary>
            This value indicates that the message was sent to one specific recipient, i.e. either by sending or replying
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe">
            <summary>
            This value indicates that the message was published to zero or more recipients, i.e. it might not actually be received by anyone.
            When auditing is enabled, a copy is always stored of published messages, regardless of the number of recipients.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that "persists" saga data in memory. Saga data is serialized/deserialized using Newtonsoft JSON.NET
            with some pretty robust settings, so inheritance and interfaces etc. can be used in the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaStorage">
            <summary>
            Abstraction for a mechanism that is capable of storing saga state, retrieving it again by querying for value on the state
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Finds an already-existing instance of the given saga data type that has a property with the given <paramref name="propertyName"/>
            whose value matches <paramref name="propertyValue"/>. Returns null if no such instance could be found
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data as a new instance. Throws a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another saga data instance
            already exists with a correlation property that shares a value with this saga data.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the already-existing instance of the given saga data, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another
            saga data instance exists with a correlation property that shares a value with this saga data, or if the saga data
            instance no longer exists.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the saga data instance, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if the instance no longer exists
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data of the given type with a property of the specified name and the specified value
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Saves the given saga data, throwing an exception if the instance already exists
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the saga data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that "persists" subscriptions in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemorySubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that "persists" timeouts in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.DbConnectionProvider">
            <summary>
            Implementation of <see cref="T:Rebus.Persistence.SqlServer.IDbConnectionProvider"/> that ensures that MARS (multiple active result sets) is enabled on the
            given connection string (possibly by enabling it by itself)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionProvider.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Wraps the connection string with the given name from app.config (if it is found), or interprets the given string as
            a connection string to use. Will use <see cref="F:System.Data.IsolationLevel.ReadCommitted"/> by default on transactions,
            unless another isolation level is set with the <see cref="P:Rebus.Persistence.SqlServer.DbConnectionProvider.IsolationLevel"/> property
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.DbConnectionProvider.IsolationLevel">
            <summary>
            Gets/sets the isolation level used for transactions
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerMagic">
            <summary>
            Wraps some nice extension methods for <see cref="T:System.Data.SqlClient.SqlConnection"/> that makes it easy e.g. to query the schema
            </summary>
        </member>
        <member name="F:Rebus.Persistence.SqlServer.SqlServerMagic.PrimaryKeyViolationNumber">
            <summary>
            Error code that is emitted on PK violations
            </summary>
        </member>
        <member name="F:Rebus.Persistence.SqlServer.SqlServerMagic.ObjectDoesNotExistOrNoPermission">
            <summary>
            Error code that is emitted when something does not exist or the login's permissions do not allow the client to see it
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerMagic.GetTableNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerMagic.GetDatabaseNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all databases on the current server
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions">
            <summary>
            Configuration extensions for configuring SQL persistence for sagas, subscriptions, and timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String,System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that persists saga data as a Newtonsoft JSON.NET-serialized object to a table in SQL Server.
            Correlation properties are stored in a separate index table, allowing for looking up saga data instanes based on the configured correlation
            properties
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the saga storage, using the specified connection provider and tables for persistence.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.EnsureTablesAreCreated">
            <summary>
            Checks to see if the configured tables exist, creating them if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Queries the saga index for an instance with the given <paramref name="sagaDataType"/> with a
            a property named <paramref name="propertyName"/> and the value <paramref name="propertyValue"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Serializes the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given <see cref="T:Rebus.Sagas.ISagaData"/> and removes all its entries in the index
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that persists subscriptions in a table in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the storage using the specified connection provider and table to store its subscriptions. If the subscription
            storage is shared by all subscribers and publishers, the <paramref name="isCentralized"/> parameter can be set to true
            in order to subscribe/unsubscribe directly instead of sending subscription/unsubscription requests
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that uses SQL Server to store messages until it's time to deliver them.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the timeout manager, using the specified connection provider and table to store the messages until they're due.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.EnsureTableIsCreated">
            <summary>
            Creates the due messages table if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Defers the message to the time specified by <paramref name="approximateDueTime"/> at which point in time the message will be
            returned to whoever calls <see cref="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.GetDueMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.GetDueMessages">
            <summary>
            Gets messages due for delivery at the current time
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.ActivateHandlersStep">
            <summary>
            Incoming message step that gets relevant handlers for the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.#ctor(Rebus.Activation.IHandlerActivator)">
            <summary>
            Constructs the step with the <see cref="T:Rebus.Activation.IHandlerActivator"/> to use to get the handler instances
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Looks up handlers for the incoming message and saves the handlers (without invoking them) to the context as a <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker">
            <summary>
            Wrapper of the handler that is ready to invoke
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.HandlerInvoker.CurrentHandlerInvokerItemsKey">
            <summary>
            Key under which the handler invoker will stash itself in the <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            during the invocation of the wrapped handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke">
            <summary>
            Method to call in order to invoke this particular handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Adds to the invoker a piece of saga data that has been determined to be relevant for the invocation
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.GetSagaData">
            <summary>
            Gets from the invoker the piece of saga data that has been determined to be relevant for the invocation, returning null if no such saga data has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.CanBeInitiatedBy(System.Type)">
            <summary>
            Gets whether the contained saga handler can be initiated by messages of the given type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SkipInvocation">
            <summary>
            Marks this handler as one to skip, i.e. calling this method will make the invoker ignore the call to <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke"/>
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.HasSaga">
            <summary>
            Gets whether this invoker's handler is a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Saga">
            <summary>
            Gets this invoker's handler as a saga (throws if it's not a saga)
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Handler">
            <summary>
            Gets the contained handler object (which is probably an implementation of <see cref="T:Rebus.Handlers.IHandleMessages"/>, but you should
            not depend on it!)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker`1">
            <summary>
            Derivation of the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> that has the message type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.#ctor(System.String,System.Func{System.Threading.Tasks.Task},System.Object,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke">
            <summary>
            Invokes the handler within this handler invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Sets a saga instance on the handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.GetSagaData">
            <summary>
            Gets the saga data (if any) that was previously set with <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)"/>. Returns null
            if none has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.CanBeInitiatedBy(System.Type)">
            <summary>
            Gets whether a message of the given type is allowed to cause a new saga data instance to be created
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SkipInvocation">
            <summary>
            Marks this handler invoker to skip its invocation, causing it to do nothin when <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke"/> is called
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler">
            <summary>
            Gets the contained handler object
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga">
            <summary>
            Gets whther the contained handler object has a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga">
            <summary>
            If <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga"/> returned true, the <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler"/> can be retrieved as a <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga"/> here
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandleDeferredMessagesStep">
            <summary>
            Incoming step that checks for the presence of the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header, using a
            <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to handle the deferral if necessary.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.#ctor(Rebus.Timeouts.ITimeoutManager,Rebus.Transport.ITransport,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step, using the specified <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to defer relevant messages
            and the specified <see cref="T:Rebus.Transport.ITransport"/> to deliver messages when they're due.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Finalize">
            <summary>
            Last-resort disposal of resources, including shutting down the <see cref="F:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.DueMessagesSenderTaskName"/> background task.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Initialize">
            <summary>
            Initialized the step (starts the <see cref="F:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.DueMessagesSenderTaskName"/> background task if using the internal timeout manager)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks to see if the incoming message has the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header. If that is the case, the message is either stored for later delivery
            or forwarded to the configured external timeout manager. If not, the message will be passed on down the pipeline.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Dispose">
            <summary>
            Last-resort disposal of the due messages background task
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Dispose(System.Boolean)">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.LoadSagaDataStep">
            <summary>
            Incoming step that loads and saves relevant saga data.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.LoadSagaDataStep.#ctor(Rebus.Sagas.ISagaStorage,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step with the given saga storage
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.LoadSagaDataStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            For each <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> found in the current <see cref="T:Rebus.Pipeline.IncomingStepContext"/>'s <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>,
            this step will see if the invoker's handler is actually a <see cref="T:Rebus.Sagas.Saga"/>. If that is the case, the saga's correlation properties
            are used to see if a piece of existing saga data can be retrieved and mounted on the <see cref="P:Rebus.Sagas.Saga`1.Data"/> property.
            If no existing instance was found, but the saga implements <see cref="T:Rebus.Sagas.IAmInitiatedBy`1"/> for the current message,
            a new saga data instance will be created (and mounted). Otherwise, the message is ignored.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.FlowCorrelationIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.CorrelationId"/> header of the outgoing message if it has not already been set.
            The value used is one of the following (in prioritized order):
            1) The correlation ID of the message currently being handled,
            2) The message ID of the message currently being handled,
            3) The message's own message ID
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.FlowCorrelationIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Flows the correlation ID like it should
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SendOutgoingMessageStep">
            <summary>
            Outgoing step that uses the current transport to send the <see cref="T:Rebus.Messages.TransportMessage"/>
            found in the context to the destination address specified by looking up
            <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> in the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step, using the specified transport to send the messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sends the outgoing message using the configured <see cref="T:Rebus.Transport.ITransport"/>, sending to the <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/>
            found in the <see cref="T:Rebus.Pipeline.OutgoingStepContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SerializeOutgoingMessageStep">
            <summary>
            Outgoing step that gets the current <see cref="T:Rebus.Messages.Message"/> from the context and serializes its body,
            saving the result as a <see cref="T:Rebus.Messages.TransportMessage"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Serializes the outgoing message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.Message"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.TransportMessage"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategy">
            <summary>
            Determines the retry strategy by providing an implementation of <see cref="T:Rebus.Retry.IRetryStrategyStep"/> which will be
            put in front of the incoming message pipeline
            </summary>
        </member>
        <member name="M:Rebus.Retry.IRetryStrategy.GetRetryStep">
            <summary>
            Should return a <see cref="T:Rebus.Retry.IRetryStrategyStep"/> which is an <see cref="T:Rebus.Pipeline.IIncomingStep"/> that implements the retry strategy
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrageConfigurationExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrageConfigurationExtensions.SimpleRetryStrategy(Rebus.Config.OptionsConfigurer,System.String,System.Int32,System.Boolean)">
            <summary>
            Configures the simple retry strategy, using the specified error queue address and number of delivery attempts
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategySettings">
            <summary>
            Contains the settings used by <see cref="T:Rebus.Retry.Simple.SimpleRetryStrategy"/>
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultErrorQueueName">
            <summary>
            Name of the default error queue, which will be used unless <see cref="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorQueueAddress"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultNumberOfDeliveryAttempts">
            <summary>
            Number of delivery attempts that will be used unless <see cref="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.MaxDeliveryAttempts"/> is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategySettings.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Creates the settings with the given error queue address and number of delivery attempts, defaulting to <see cref="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultErrorQueueName"/> and <see cref="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultNumberOfDeliveryAttempts"/> 
            as the error queue address and number of delivery attempts, respectively
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorQueueAddress">
            <summary>
            Name of the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.MaxDeliveryAttempts">
            <summary>
            Number of attempted deliveries to make before moving the poisonous message to the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.SecondLevelRetriesEnabled">
            <summary>
            Configures whether an additional round of delivery attempts should be made with a <see cref="T:Rebus.Retry.Simple.Failed`1"/> wrapping the originally failed messageS
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategy">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IRetryStrategy"/> that tracks errors in memory
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategy.#ctor(Rebus.Transport.ITransport,Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Retry.IErrorTracker,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the retry strategy with the given settings, creating an error queue with the configured name if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategy.GetRetryStep">
            <summary>
            Gets the retry step with appropriate settings for this <see cref="T:Rebus.Retry.Simple.SimpleRetryStrategy"/>
            </summary>
        </member>
        <member name="T:Rebus.Routing.TopicBased.TopicBasedRouter">
            <summary>
            Implementation of <see cref="T:Rebus.Routing.IRouter"/> that uses string-based topics to do its thing
            </summary>
        </member>
        <member name="T:Rebus.Routing.IRouter">
            <summary>
            Abstraction of the routing logic. Should be capable of returning a destination address for a message
            and an owner address for a topic.
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Called when sending messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)">
            <summary>
            Called when subscribing to messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouter.Map(System.String,System.String)">
            <summary>
            Maps the specified topic to the specified address
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Called when sending messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouter.GetOwnerAddress(System.String)">
            <summary>
            Called when subscribing to messages
            </summary>
        </member>
        <member name="T:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions">
            <summary>
            Router configuration extensions that help with setting up a topic-based routing
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBased(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter})">
            <summary>
            Selectes topic-based routing
            </summary>
        </member>
        <member name="T:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBasedRouterConfigurationBuilder">
            <summary>
            Builder that can help with mapping topics to addresses
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBasedRouterConfigurationBuilder.#ctor(Rebus.Routing.TopicBased.TopicBasedRouter)">
            <summary>
            Constructs the builder
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBasedRouterConfigurationBuilder.Map(System.String,System.String)">
            <summary>
            Maps the specified topic to the specified address
            </summary>
        </member>
        <member name="T:Rebus.Sagas.CorrelationProperty">
            <summary>
            Represents a mapping from a field of an incoming message of a specific type to a specific property on a specific type of saga data
            </summary>
        </member>
        <member name="F:Rebus.Sagas.CorrelationProperty.AllowedCorrelationPropertyTypes">
            <summary>
            Defines the types that are allowed to use with saga data properties that are intended for correlation
            </summary>
        </member>
        <member name="M:Rebus.Sagas.CorrelationProperty.#ctor(System.Type,System.Func{System.Object,System.Object},System.Type,System.String,System.Type)">
            <summary>
            Constructs the correlation property
            </summary>
            <param name="messageType">Specifies the message type that this property can correlate</param>
            <param name="valueFromMessage">Specifies the function that will be called with the message instance in order to extract a value that should be used for correlation</param>
            <param name="sagaDataType">Specifies the type of saga data that this property can correlate to</param>
            <param name="propertyName">Specifies that property name on the saga data that this correlation addresses</param>
            <param name="sagaType">Specifies the saga type (i.e. the handler type) that contains the logic of the saga</param>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.MessageType">
            <summary>
            The message type that this property can correlate
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.ValueFromMessage">
            <summary>
            The function that will be called with the message instance in order to extract a value that should be used for correlation
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga's saga data
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.PropertyName">
            <summary>
            Gets the name of the correlation property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaType">
            <summary>
            The saga type (i.e. the handler type) that contains the logic of the saga
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaHelper">
            <summary>
            Helper class that can cache configured sets of correlation properties for various saga types
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.GetCorrelationProperties(System.Object,Rebus.Sagas.Saga)">
            <summary>
            Gets (most likely from a cache) the set of correlation properties relevant for the given saga handler.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.CreateNewSagaData(Rebus.Sagas.Saga)">
            <summary>
            Creates a new instance of the saga's saga data
            </summary>
        </member>
        <member name="T:Rebus.Time.RebusTime">
            <summary>
            Global clock that Rebus services should use if they need to look up the current time
            </summary>
        </member>
        <member name="P:Rebus.Time.RebusTime.Now">
            <summary>
            Gets the current time
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemNetwork">
            <summary>
            Defines a network that the in-mem transport can work on, functioning as a namespace for the queue addresses
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.#ctor(System.Boolean)">
            <summary>
            Constructs the in-mem network, optionally (if <paramref name="outputEventsToConsole"/> is set to true) outputting information
            about what is happening inside it to <see cref="P:System.Console.Out"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Reset">
            <summary>
            Resets the network (i.e. all queues and their messages are deleted)
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Deliver(System.String,Rebus.Transport.InMem.InMemTransportMessage,System.Boolean)">
            <summary>
            Delivers the specified <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> to the address specified by <paramref name="destinationAddress"/>.
            If <paramref name="alwaysQuiet"/> is set to true, no events will ever be printed to <see cref="P:System.Console.Out"/>
            (can be used by an in-mem transport to return a message to a queue, as if there was a queue transaction that was rolled back)
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.GetNextOrNull(System.String)">
            <summary>
            Gets the next message from the queue with the given <paramref name="inputQueueName"/>, returning null if no messages are available.
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.HasQueue(System.String)">
            <summary>
            Returns whether the network has a queue with the specified name
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.CreateQueue(System.String)">
            <summary>
            Creates a queue on the network with the specified name
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransport">
            <summary>
            In-mem implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses one particular <see cref="T:Rebus.Transport.InMem.InMemNetwork"/> to deliver messages. Can
            be used for in-process messaging and unit testing
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.#ctor(Rebus.Transport.InMem.InMemNetwork,System.String)">
            <summary>
            Creates the transport, using the specified <see cref="T:Rebus.Transport.InMem.InMemNetwork"/> to deliver/receive messages. This transport will have
            <paramref name="inputQueueAddress"/> as its input queue address, and thus will attempt to receive messages from the queue with that
            name out of the given <paramref name="network"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.CreateQueue(System.String)">
            <summary>
            Creates a queue with the given address
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Delivers the given message to the queue identitied by the given <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Receive(Rebus.Transport.ITransactionContext)">
            <summary>
            Receives the next message from the queue identified by the configured <see cref="P:Rebus.Transport.InMem.InMemTransport.Address"/>, returning null if none was available
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Initialize">
            <summary>
            Initializes the transport by creating its own input queue
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransport.Address">
            <summary>
            Gets the input queue
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the in-mem transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportConfigurationExtensions.UseInMemoryTransport(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Transport.InMem.InMemNetwork,System.String)">
            <summary>
            Configures Rebus to use in-mem message queues, delivering/receiving from the specified <see cref="T:Rebus.Transport.InMem.InMemNetwork"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportConfigurationExtensions.UseInMemoryTransportAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Transport.InMem.InMemNetwork)">
            <summary>
            Configures Rebus to use in-mem message queues, configuring this instance to be a one-way client
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportMessage">
            <summary>
            Represents a transport message that was delivered to an in-mem message queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessage.#ctor(Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the in-mem transport message from the given <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessage.ToTransportMessage">
            <summary>
            Returns this in-mem transport message's headers and body in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Age">
            <summary>
            Gets the age of this in-mem transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Headers">
            <summary>
            Gets the headers of this in-mem transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Body">
            <summary>
            Gets the body data of this in-mem transport message
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportMessageExtensions">
            <summary>
            Extensions that make it nice to work with <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> and <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessageExtensions.ToInMemTransportMessage(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a new <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> containing the headers and the body data of the <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the MSMQ transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransportConfigurationExtensions.UseMsmq(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String)">
            <summary>
            Configures Rebus to use MSMQ to transport messages, receiving messages from the specified <paramref name="inputQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransportConfigurationExtensions.UseMsmqAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Configures Rebus to use MSMQ to transport messages as a one-way client (i.e. will not be able to receive any messages)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.DefaultPipeline">
            <summary>
            Default pipeline implementation that can be built with a fluent syntax by calling <see cref="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)"/> and <see cref="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)"/> respectively,
            in the order that the steps must be invoked in.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.SendPipeline">
            <summary>
            Gets the send pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)">
            <summary>
            Adds a new incoming step to the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)">
            <summary>
            Adds a new outgoing step to the send pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipelineInvoker">
            <summary>
            The invoker is capable of invoking an ordered pipeline of steps
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IIncomingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IOutgoingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.DefaultPipelineInvoker">
            <summary>
            give me a pipeline and I'll invoke it
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IIncomingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IOutgoingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep">
            <summary>
            Incoming step that gets the current <see cref="T:Rebus.Messages.TransportMessage"/> from the context and deserializes its body,
            saving the result as a <see cref="T:Rebus.Messages.Message"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Deserializes the incoming message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.TransportMessage"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.Message"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DispatchIncomingMessageStep">
            <summary>
            Incoming step that gets a <see cref="T:System.Collections.Generic.List`1"/> where T is <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> from the context
            and invokes them in the order they're in.
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.AbortDispatchContextKey">
            <summary>
            Keys of an <see cref="T:Rebus.Pipeline.IncomingStepContext"/> items that indicates that message dispatch must be stopped
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Processes the message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategyStep">
            <summary>
            Incoming message pipeline step that implements a retry mechanism - if the call to the rest of the pipeline fails,
            the exception is caught and the queue transaction is rolled back. Caught exceptions are tracked in-mem, and after
            a configurable number of retries, the message will be forwarded to the configured error queue and the rest of the pipeline will not be called
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategyStep.DispatchAsFailedMessageKey">
            <summary>
            Key of a step context item that indicates that the message must be wrapped in a <see cref="T:Rebus.Retry.Simple.Failed`1"/> after being deserialized
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyStep.#ctor(Rebus.Transport.ITransport,Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Retry.IErrorTracker,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step, using the given transport and settings
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the entire message processing pipeline in an exception handler, tracking the number of failed delivery attempts.
            Forwards the message to the error queue when the max number of delivery attempts has been exceeded.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignGuidMessageIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.MessageId"/> header of the outgoing message, unless it has already been set.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignGuidMessageIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.MessageId"/>. The message ID is a new <see cref="T:System.Guid"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignReturnAddressStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the outgoing message to the input queue
            address (found with <see cref="P:Rebus.Transport.ITransport.Address"/>), unless the header has already been set to something else.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignReturnAddressStep.#ctor(Rebus.Transport.ITransport)">
            <summary>
            Constructs the step, getting the input queue address from the given <see cref="T:Rebus.Transport.ITransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignReturnAddressStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            If no return address has been added to the message, the sender's input queue address is automatically added as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/>
            header
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouter">
            <summary>
            Routing logic that maps types to owning endpoints.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the router
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Gets the destination address for the given message
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetOwnerAddress(System.String)">
            <summary>
            Looks up the owner of the topic which is assumed to be an assembly-qualified name of an available .NET type
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions">
            <summary>
            Configuration extensions for configuring type-based routing (i.e. routing where each message type has one, single unambiguous
            owning endpoint)
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBased(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter})">
            <summary>
            Configures Rebus to use type-based routing
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder">
            <summary>
            Type-based routing configuration builder that can be called fluently to map message types to their owning endpoints
            </summary>
        </member>
        <member name="F:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder._configurationActions">
            <summary>
            We use this way of storing configuration actions in order to preserve the order
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqTransport">
            <summary>
            Implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses MSMQ to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the transport with the specified input queue address
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Finalize">
            <summary>
            Last-resort disposal of the transport's message queues
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Initialize">
            <summary>
            Initializes the transport by creating the input queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.CreateQueue(System.String)">
            <summary>
            Creates a queue with the given address, unless the address is of a remote queue - in that case,
            this call is ignored
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.PurgeInputQueue">
            <summary>
            Deletes all messages in the input queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified destination address using MSMQ. Will use the existing <see cref="T:System.Messaging.MessageQueueTransaction"/> stashed
            under the <see cref="F:Rebus.Transport.Msmq.MsmqTransport.CurrentTransactionKey"/> key in the given <paramref name="context"/>, or else it will create one and add it.
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Receive(Rebus.Transport.ITransactionContext)">
            <summary>
            Received the next available transport message from the input queue via MSMQ. Will create a new <see cref="T:System.Messaging.MessageQueueTransaction"/> and stash
            it under the <see cref="F:Rebus.Transport.Msmq.MsmqTransport.CurrentTransactionKey"/> key in the given <paramref name="context"/>. If one already exists, an exception will be thrown
            (because we should never have to receive multiple messages in the same transaction)
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Dispose">
            <summary>
            Disposes the input message queue object
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Dispose(System.Boolean)">
            <summary>
            Disposes the input queue instance
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.UseLegacyHeaderSerialization">
            <summary>
            Configures the transport to serialize headers in "legacy mode", which means that they're UTF7-encoded and not UTF8
            </summary>
        </member>
        <member name="P:Rebus.Transport.Msmq.MsmqTransport.Address">
            <summary>
            Gets the input queue address of this MSMQ queue
            </summary>
        </member>
        <member name="T:Rebus.Messages.TransportMessage">
            <summary>
            Transport message wrapper that has a set of headers and a stream of raw data to be sent/received
            </summary>
        </member>
        <member name="M:Rebus.Messages.TransportMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Constructs the transport message with the given headers, wrapping the given body payload
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Body">
            <summary>
            Gets the wrapped body data of this message
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqUtil">
            <summary>
            Utils class for various MSMQ operations
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.PurgeQueue(System.String)">
            <summary>
            Deletes all messages from the queue with the specified name
            </summary>
            <param name="queueName"></param>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.GetPath(System.String)">
            <summary>
            Gets the MSMQ style path for the queue with the given name
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.GetFullPath(System.String)">
            <summary>
            Gets the MSMQ style path for the queue with the given name, always machine-qualified, even when the queue is local
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.GenerateFullPath(System.String,System.String)">
            <summary>
            Generates from the given <paramref name="machineName"/> and <paramref name="queueName"/> the full, MSMQ style queue path.
            It goes something like this: <code>FormatName:DIRECT=OS:SOME_MACHINE\private$\SOME_QUEUE</code> when addressing
            by machine name, and like this <code>FormatName:DIRECT=TCP:10.10.1.1\private$\SOME_QUEUE</code> when addressing
            by IP address.
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.QueueExists(System.String)">
            <summary>
            Returns whether an MSMQ queue with the given name exists
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.Delete(System.String)">
            <summary>
            Deletes the MSMQ queue with the given name
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.EnsureQueueExists(System.String,Rebus.Logging.ILog)">
            <summary>
            Creates the MSMQ queue with the specified path if it does not already exist. If it is created, the user account
            of the currently executing process will get <see cref="F:System.Messaging.MessageQueueAccessRights.GenericWrite"/> permissions to it,
            and the local administrators group will get <see cref="F:System.Messaging.MessageQueueAccessRights.FullControl"/>.
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.EnsureMessageQueueIsTransactional(System.String)">
            <summary>
            Verifies that the queue with the given <paramref name="path"/> is transaction. If that is not the case, a <see cref="T:Rebus.Exceptions.RebusApplicationException"/>
            is thrown with an explanation of the problem
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.IsLocal(System.String)">
            <summary>
            Returns whther the queue with the specified name is local
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DictionaryExtensions">
            <summary>
            Provides some nifty extensions to <see cref="T:System.Collections.Generic.Dictionary`2"/> and <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.MergedWith``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a new dictionary that contains all key-value pairs from both dictionaries. If the same key is present the value from <paramref name="otherDictionary"/> takes precedence
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.Clone(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Returns a new dictionary with the same key-value pairs as the target
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValue(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, throwing a MUCH nicer <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValueOrNull(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, returning null if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})">
            <summary>
            Provides a function similar to <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>, only
            on <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAddAsync``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Provides a function similar to <see cref="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})"/>, only where the factory function can be async
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.ToConcurrentDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Maps the given sequence of items to key-value pairs, returning them in a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrThrow``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrNull``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ISerializer">
            <summary>
            Message serializer that should capable of safely roundtripping .NET message body objects to some serialized form and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.JsonSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.Serialization.ISerializer"/> that uses Newtonsoft JSON.NET internally, with some pretty robust settings
            (i.e. full type info is included in the serialized format in order to support deserializing "unknown" types like
            implementations of interfaces, etc)
            </summary>
        </member>
        <member name="F:Rebus.Serialization.JsonSerializer.JsonUtf8ContentType">
            <summary>
            Proper content type when a message has been serialized with this serializer (or another compatible JSON serializer) and it uses the standard UTF8 encoding
            </summary>
        </member>
        <member name="F:Rebus.Serialization.JsonSerializer.JsonContentType">
            <summary>
            Contents type when the content is JSON
            </summary>
        </member>
        <member name="M:Rebus.Serialization.JsonSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.JsonSerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Messages.Message">
            <summary>
            Logical message wrapper that has a set of headers and a .NET object
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Object)">
            <summary>
            Constructs the message with the specified headers, wrapping the given .NET object as the message body
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Body">
            <summary>
            Gets the wrapped body object of this message
            </summary>
        </member>
        <member name="T:Rebus.Transport.DefaultTransactionContext">
            <summary>
            Default implementation of <see cref="T:Rebus.Transport.ITransactionContext"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransactionContext">
            <summary>
            Represents the context of one queue transaction
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called when the queue transaction is committed. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnAborted(System.Action)">
            <summary>
            Registers a listener to be called when the queue transaction is aborted. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnCompleted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called AFTER the queue transaction has been successfully committed (i.e. all listeners
            registered with <see cref="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})"/> have been executed). This would be a good place to complete the incoming
            message.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnDisposed(System.Action)">
            <summary>
            Registers a listener to be called after the transaction is over
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.Abort">
            <summary>
            Signals that something is wrong and the queue transaction must be aborted
            </summary>
        </member>
        <member name="P:Rebus.Transport.ITransactionContext.Items">
            <summary>
            Stash of items that can carry stuff for later use in the transaction
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.#ctor">
            <summary>
            Constructs the transaction context
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called when the queue transaction is committed. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnCompleted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called AFTER the queue transaction has been successfully committed (i.e. all listeners
            registered with <see cref="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})"/> have been executed). This would be a good place to complete the incoming
            message.
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnAborted(System.Action)">
            <summary>
            Registers a listener to be called when the queue transaction is aborted. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnDisposed(System.Action)">
            <summary>
            Registers a listener to be called after the transaction is over
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Abort">
            <summary>
            Indicates that the transaction must not be committed and commit handlers must not be run
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Dispose">
            <summary>
            Performs the registered cleanup actions. If the transaction has not been committed, it will be aborted before the cleanup happens.
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Complete">
            <summary>
            Ends the current transaction but either committing it or aborting it, depending on whether someone voted for abortion
            </summary>
        </member>
        <member name="P:Rebus.Transport.DefaultTransactionContext.Items">
            <summary>
            Stash of items that can carry stuff for later use in the transaction
            </summary>
        </member>
        <member name="T:Rebus.Transport.SqlServer.SqlServerTransport">
            <summary>
            Implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses SQL Server to do its thing
            </summary>
        </member>
        <member name="F:Rebus.Transport.SqlServer.SqlServerTransport.MessagePriorityHeaderKey">
            <summary>
            Special message priority header that can be used with the <see cref="T:Rebus.Transport.SqlServer.SqlServerTransport"/>. The value must be an <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:Rebus.Transport.SqlServer.SqlServerTransport.DefaultExpiredMessagesCleanupInterval">
            <summary>
            Default interval that will be used for <see cref="P:Rebus.Transport.SqlServer.SqlServerTransport.ExpiredMessagesCleanupInterval"/> unless it is explicitly set to something else
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the transport with the given <see cref="T:Rebus.Persistence.SqlServer.IDbConnectionProvider"/>, using the specified <paramref name="tableName"/> to send/receive messages,
            querying for messages with recipient = <paramref name="inputQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Finalize">
            <summary>
            Last-resort disposal of resoures - shuts down the 'ExpiredMessagesCleanup' background task
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Initialize">
            <summary>
            Initializes the transport by starting a task that deletes expired messages from the SQL table
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.CreateQueue(System.String)">
            <summary>
            The SQL transport doesn't really have queues, so this function does nothing
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.EnsureTableIsCreated">
            <summary>
            Checks if the table with the configured name exists - if not, it will be created
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified logical destination address by adding it to the messages table.
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Receive(Rebus.Transport.ITransactionContext)">
            <summary>
            Receives the next message by querying the messages table for a message with a recipient matching this transport's <see cref="P:Rebus.Transport.SqlServer.SqlServerTransport.Address"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Dispose">
            <summary>
            Shuts down the background timer
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Dispose(System.Boolean)">
            <summary>
            Shuts down the background timer
            </summary>
        </member>
        <member name="P:Rebus.Transport.SqlServer.SqlServerTransport.ExpiredMessagesCleanupInterval">
            <summary>
            Configures the interval between periodic deletion of expired messages. Defaults to <see cref="F:Rebus.Transport.SqlServer.SqlServerTransport.DefaultExpiredMessagesCleanupInterval"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.SqlServer.SqlServerTransport.Address">
            <summary>
            Gets the name that this SQL transport will use to query by when checking the messages table
            </summary>
        </member>
        <member name="T:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the SQL transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String)">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The table specified by <paramref name="tableName"/> will be used to store messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String,System.String)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The table specified by <paramref name="tableName"/> will be used to
            store messages, and the "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="T:Rebus.Workers.IWorkerFactory">
            <summary>
            Factory responsible for creating a "worker"
            </summary>
        </member>
        <member name="M:Rebus.Workers.IWorkerFactory.CreateWorker(System.String)">
            <summary>
            Must create a new worker with the given name
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadBased.ThreadWorkerFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorkerFactory"/> that creates <see cref="T:Rebus.Workers.ThreadBased.ThreadWorker"/> instances when asked for
            an <see cref="T:Rebus.Workers.IWorker"/>. Each <see cref="T:Rebus.Workers.ThreadBased.ThreadWorker"/> has its own dedicated worker thread that performs
            all the work (which consists of receiving new messages and running continuations)
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerFactory.#ctor(Rebus.Transport.ITransport,Rebus.Pipeline.IPipeline,Rebus.Pipeline.IPipelineInvoker,System.Int32,Rebus.Workers.IBackoffStrategy,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerFactory.CreateWorker(System.String)">
            <summary>
            Creates a new worker (i.e. a new thread) with the given name
            </summary>
        </member>
    </members>
</doc>
